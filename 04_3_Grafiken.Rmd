---
title: "3_Grafiken"
author: "AnfPrak"
date: '2022-04-11'
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
Sys.setenv(TZ = "Europe/Berlin")
```



```{r [optional] clean environment, include = FALSE}
SWITCH_clean_environment <- 1
if (SWITCH_clean_environment == 1) {
  rm(list = ls())
  gc()
}
```



```{r libraries}
######################################
#### Package / Library setup
######################################
# Specifies which packages are used and installs / loads all that are required
lib_need <- c("zoo",
              "tidyverse",
              "gridExtra",
              "vctrs",
              "reldist")
lib_have <- lib_need %in% rownames(installed.packages())

if(any(!lib_have)) install.packages(lib_need[!lib_have])
invisible(lapply(lib_need, library, character.only = TRUE))

rm(lib_have, lib_need)
######################################
```


# Erstellung der Grafiken, wie sie im Vortrag vorkamen, auf der ursprünglichen Datenbasis


```{r data import}

######################################
#### Data import
######################################

# Requires: 03_7_cases_complete_Vortrag_ADD.rds
#           03_9_RKI_covid_2022-03-26.Rds
#
# Output:   cases_complete (df)
#           cases_exa (df)
#           current_covid (df)

setwd(getwd()) # Change working directory if necessary

cases_complete <- readRDS("03_7_cases_complete_Vortrag_ADD.rds")

# Remove the first days 0 entries
cases_exa <- subset(cases_complete, new_case != 0 | publication_date != as.Date("2020-03-27"))

# RKI Covid data downloaded on the 26th of March 2022 to visualise pandemic
current_covid <- readRDS("03_9_RKI_covid_2022-03-26.Rds")

######################################

```



```{r date vector}

######################################
#### Date vector for subset creation
######################################

# Creates a vector with all dates that are part of the dataset. This makes it
# easier for subsequent subsets created for specific visualisations
#
# Required: none
#
# Output:   dates (df)

date <- seq.Date(from = as.Date("2020-03-27"),
                 to = as.Date("2022-02-22"),
                 by = "day")

removed_date <- as.Date(c("2020-04-07",
                          "2020-04-30",
                          "2020-05-19",
                          "2020-07-14",
                          "2020-09-20",
                          "2021-09-09",
                          "2021-10-26"))

publication_dates <- data.frame(date[- which(date %in% removed_date)])
names(publication_dates) <- "publication_date"

dates <- data.frame(seq.Date(from = as.Date("2020-03-27"),
                             to = as.Date("2022-02-21"),
                             by = "day"))
names(dates) <- "date"

rm(removed_date)

######################################

```



```{r delay category calculations}

######################################
#### Universal variables
######################################

# Calculates whether a case report was delayed, or not
cases_complete$ADD_delay_break <- cut(as.numeric(cases_complete$ADD_delay), 
                         breaks = c(-1, 0, Inf),
                         labels = c("on time", "late"))

# Calculates whether a case report was delayed, or not
cases_exa$ADD_delay_break <- cut(as.numeric(cases_exa$ADD_delay), 
                         breaks = c(-1, 0, Inf),
                         labels = c("on time", "late"))

######################################

```



```{r Slide 2 All covid cases}

######################################
#### Daily covid cases since the start of the pandemic
######################################

# Current RKI data is in German, thus variable names are different
current_covid <- current_covid[c( "Meldedatum", "AnzahlFall")]
names(current_covid) <- c("date", "cases")

# transformation so case numbers are displayed properly
current_covid$date <- as.Date(current_covid$date)
current_covid$cases <- current_covid$cases / 1000

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = current_covid, 
       aes(x = date, y = cases)) +
  geom_bar(stat = "identity") +
  geom_vline(xintercept = as.Date(c("2020-01-01", "2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Der Verlauf der Pandemie: Neue Coronafälle pro Tag",
       x = "Datum des Falles",
       y = "Anzahl an Fälle (in Tsd.)") +
  theme_bw()

ggsave("Grafik_Vortrag_Folie_02_Covidfälle.png", height = 5, width = 9)

######################################

```



```{r Slide 10 Histogram of cases with delays}

######################################
#### Histogram of all cases with specified delays
######################################

# Simple plot of how many cases are in each delay category
delay_overall <- subset(cases_complete, new_case == 1) %>%
    group_by(ADD_delay) %>%
    summarise(sum(cases))
names(delay_overall) <- c("delay", "cases")

# Need to create categories because without the graph is unusable (delays extend
# up to 736 days into the future with 632 different delay observations as a whole)
delay_overall$delay_cat <- cut(as.numeric(delay_overall$delay),
                               breaks = c(-1, 0, 1, 2, 3, 4, 5, 10, 30, Inf),
                               labels = c("0", "1", "2", "3", "4", "5", "5-10", "10-30", "30+"))

delay_overall$cases <- delay_overall$cases / sum(subset(cases_complete, new_case == 1)$cases) 

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = aggregate(cases ~ delay_cat, delay_overall, sum), 
       aes(x = delay_cat, y = cases)) +
  geom_bar(stat = "identity") +
  labs(title = "Anteil an Fällen mit Meldeverzug",
       x = "Meldeverzug in Tagen",
       y = "Anteil aller Fälle") +
  theme_bw()

ggsave("Grafik_Vortrag_Folie_10_Meldeverzug_Hist.png", height = 5, width = 9)

```



### Plots for weekly cycles

Create the plots for the presentation.

```{r Slide 11 Weekly cycles}

######################################
#### Cyclicality of new cases and delays
######################################

cases_limited <- subset(cases_exa, date %in% publication_dates$publication_date)

cases_limited$date_cut <- cut(cases_limited$date,
                              breaks = as.Date(c("2020-03-25",
                                                 "2020-07-26",
                                                 "2020-11-26",
                                                 "2021-03-26",
                                                 "2021-07-26",
                                                 "2021-11-26",
                                                 "2022-02-23")),
                              labels = c("27.03 - 26.07.2020",
                                         "27.07 - 26.11.2020",
                                         "27.11.2020 - 26.03.2021",
                                         "27.03 - 26.07.2021",
                                         "27.07 - 26.11.2021",
                                         "27.11.2021 - 22.02.2022"))

temp <- subset(cases_limited,
               new_case == 1) %>%
  group_by(date_cut, date, ADD_delay_break) %>%
  summarise(n = sum(cases)) %>%
  mutate(freq = n / sum(n))


# Visualising cyclicality of new cases
p1 <- ggplot(data = subset(cases_limited, new_case == 1 & date %in% 
                             seq.Date(from = as.Date("2020-11-27"),
                                      to = as.Date("2021-07-26"),
                                      by = "day")),
             aes(x = date, y = cases)) +
  stat_summary(fun = "sum", geom = "line") +
  scale_x_date(breaks = seq.Date(from = as.Date("2020-03-29"),
                                 to = as.Date("2022-02-22"),
                                 by = "week"),
               date_labels = "%a\n%b\n%Y") +
  geom_vline(xintercept = seq.Date(from = as.Date("2020-03-29"),
                                   to = as.Date("2022-02-22"),
                                   by = "week"),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Wöchentlicher Zyklus der Anzahl der Neuinfektionsmeldungen im Zeitraum 27.11.2020 - 26.07.2021",
       x = "Meldedatum",
       y = "Fälle") +
  theme_bw() +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 7))


# Visualising cyclicality of delays
p2 <- ggplot(data = subset(temp, ADD_delay_break == "late" & date %in%
                             seq.Date(from = as.Date("2020-11-27"),
                                      to = as.Date("2021-07-26"),
                                      by = "day")),
             aes(x = date)) +
  geom_line(aes(y = freq)) +
  theme_bw() +
  scale_x_date(breaks = seq.Date(from = as.Date("2020-03-29"),
                                 to = as.Date("2022-02-22"),
                                 by = "week"),
               date_labels = "%a\n%b\n%Y") +
  geom_vline(xintercept = seq.Date(from = as.Date("2020-03-29"),
                                   to = as.Date("2022-02-22"),
                                   by = "week"),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Wöchentlicher Zyklus des Anteils der Spätmeldungen* im Zeitraum 27.11.2020 - 26.07.2021",
       x = "Meldedatum",
       caption = "*Meldungen mit Verzug mind. 1 Tag.\nfreq = n(Spätmeldugen am Meldedatum) / n(alle Meldungen am Meldedatum)") +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 7))

# Combining both graphs into one for easier arragement on slide
png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_11_Zyklus.png"),
    width = 9000,
    height = 5000,
    res = 900)
grid.arrange(p1, p2, nrow = 2)
dev.off()


# Visualisation showing that the cyclicality of new cases holds over entire period
png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_29_Neuinfektionen_Zyklus.png"),
    width = 14000,
    height = 7000,
    res = 900)

ggplot(data = subset(cases_limited, new_case == 1),
       aes(x = date, y = cases)) +
  stat_summary(fun = "sum", geom="line") +
  scale_x_date(breaks = seq.Date(from = as.Date("2020-03-29"),
                                 to = as.Date("2022-02-22"),
                                 by = "week"),
               date_labels = "%a\n%b\n%Y") +
  geom_vline(xintercept = seq.Date(from = as.Date("2020-03-29"),
                                   to = as.Date("2022-02-22"),
                                   by = "week"),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Wöchentlicher Zyklus der Anzahl der Neuinfektionsmeldungen",
       x = "Meldedatum",
       y = "Fälle") +
  theme_bw() +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 7)) +
  facet_wrap(~date_cut, scales = "free")
dev.off()


# Visualisation showing that the cyclicality of delays holds over entire period
png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_30_Spaetmeldungsanteil_Zyklus.png"),
    width = 14000,
    height = 7000,
    res = 900)

ggplot(subset(temp, ADD_delay_break == "late"),
       aes(x = date)) +
  geom_line(aes(y = freq)) +
  theme_bw() +
  scale_x_date(breaks = seq.Date(from = as.Date("2020-03-29"),
                                 to = as.Date("2022-02-22"),
                                 by = "week"),
               date_labels = "%a\n%b\n%Y") +
  geom_vline(xintercept = seq.Date(from = as.Date("2020-03-29"),
                                   to = as.Date("2022-02-22"),
                                   by = "week"),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Wöchentlicher Zyklus des Anteils der Spätmeldungen*",
       x = "Meldedatum",
       caption = "*Meldungen mit Verzug mind. 1 Tag.\nfreq = n(Spätmeldugen am Meldedatum) / n(alle Meldungen am Meldedatum)") +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 7)) +
  facet_wrap(~date_cut, scales = "free")
dev.off()

rm(p1, p2, cases_limited, temp)
gc()

######################################

```




```{r Slide 12 Daily proportion of delayed cases}


case_delay <- data.frame(date = double(),
                         late_cases = double(),
                         cases = double(),
                         prop_late = double(),
                         late_roll = double())


# Calculates the number of late cases
temp <- subset(cases_complete, new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
names(temp) <- c("date", "late_cases")

# Calculates the number of total cases
temp2 <- subset(cases_complete, new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
names(temp2) <- c("date", "cases")
  
# ensuring that the dataframe has a list of complete dates (introduces NAs)
temp <- left_join(dates, data.frame(temp), by = "date")
temp <- left_join(data.frame(temp), data.frame(temp2), by = "date")
temp$prop_late <- temp$late_cases / temp$cases
  
# Decided to use the "extend" method so if there is an NA, the leftmost rolling
# average value will be repeated until a new one can be calculated. This also
# means that an NA value creates a plateau of the average for 7 values. Using 
# NA (or NULL) as the method creates an NA value for the entire 7 days which 
# creates gaps in the visualisation
temp$late_roll <- rollmean(temp$prop_late, 7, fill = "extend",  align = "right")
case_delay <- rbind(case_delay, temp)

rm(temp, temp2)

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_delay,
       aes(x = date)) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_12_Meldeverzug_Anteil.png", height = 5, width = 9)

## REVISED Visualisation

# Moved the vertical year denominator behind the other lines

ggplot(data = case_delay,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_12_Meldeverzug_Anteil.png", height = 5, width = 9)

######################################

```


```{r Slides 13-15 Delay quantiles}

# Calculation of quantile delay on all cases
delay_overall_quant <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .50, weight = cases))
names(delay_overall_quant) <- c("date", "q50_delay")
  
delay_overall_quant <- left_join(dates, delay_overall_quant, by = "date")
delay_overall_quant$q50_roll <- rollmean(delay_overall_quant$q50_delay, 7, fill = "extend",  align = "right")


q90 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
names(q90) <- c("date", "q90_delay")
q90 <- left_join(dates, q90, by = "date")
q90$q90_roll <- rollmean(q90$q90_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q90_delay <- q90$q90_delay
delay_overall_quant$q90_roll <- q90$q90_roll
rm(q90)


q95 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .95, weight = cases))
names(q95) <- c("date", "q95_delay")
q95 <- left_join(dates, q95, by = "date")
q95$q95_roll <- rollmean(q95$q95_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q95_delay <- q95$q95_delay
delay_overall_quant$q95_roll <- q95$q95_roll
rm(q95)


q99 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .99, weight = cases))
names(q99) <- c("date", "q99_delay")
q99 <- left_join(dates, q99, by = "date")
q99$q99_roll <- rollmean(q99$q99_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q99_delay <- q99$q99_delay
delay_overall_quant$q99_roll <- q99$q99_roll
rm(q99)


## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))


# Absolute delay of q90 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  ylim(0, 400) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_13_Meldeverzug_q90.png", height = 5, width = 9)


# Absolute delay of q95 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  ylim(0, 400) +
  geom_line(aes(y = q95_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q95_roll, colour = "Gewichteter Mittelwert")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Zeit nach der 95% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 95%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_14_Meldeverzug_q95.png", height = 5, width = 9)


# Absolute delay of q99 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  ylim(0, 400) +
  geom_line(aes(y = q99_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q99_roll, colour = "Gewichteter Mittelwert")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Zeit nach der 99% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 99%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_15_Meldeverzug_q99.png", height = 5, width = 9)

```




### Plots 7-day incidence

Create the plots for presentation.

```{r Slides 16-17 create presentation plots for 7-day-incidence}

population_2019 <- 83166711
population_2020 <- 83155031

incidence <- vec_rep(0, 691)

temp <- publication_dates$publication_date
# 7-days-incidence can only be computed with i>=8
# for 2020
for (i in 8:275) {
  # take all addtional reports and corrections till 22.02.2022
  incidence[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)])$cases)/population_2019*100000 
}
# from 2021
for (i in 276:691) {
  # take all additional reports and corrections till 22.02.2022
  incidence[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)])$cases)/population_2020*100000
}

incidence_original <- vec_rep(0,691)
# for 2020
for (i in 8:275) {
  # Take only reports and corrections until the publication date of the incidence
  incidence_original[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):i])$cases)/population_2019*100000
}
# from 2021
for (i in 276:691) {
  # Take only reports and corrections until the publication date of the incidence
  incidence_original[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):i])$cases)/population_2020*100000
}

incidence_orig_plus1 <- vec_rep(0,691)
# for 2020
for (i in 8:275) {
  # Take only reports and corrections up to the date of the incidence + 1
  incidence_orig_plus1[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):(i+1)])$cases)/population_2019*100000
}
# from 2021
for (i in 276:691) {
  # Take only reports and corrections up to the date of the incidence + 1
  incidence_orig_plus1[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):(i+1)])$cases)/population_2020*100000
}

df_plot <- publication_dates
names(df_plot) <- "date"
df_plot$incidence <- incidence
df_plot$incidence_original <- incidence_original
df_plot$incidence_orig_plus1 <- incidence_orig_plus1

png(file.path(".","05_Grafiken","Grafik_Vortrag_Folie_16_Inzidenz.png"),
    width = 9000,
    height = 5000,
    res = 900)

ggplot(data = df_plot, aes(x = date)) +
  geom_line(aes(y = incidence,
                color = "korrigierte Inzidenz durch Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022"),
            linetype = 2) +
  geom_line(aes(y = incidence_original,
                color = "Inzidenz am Veröffentlichungstag")) +
  labs(title = "Einfluss von Nachmeldungen & -korrekturen auf die 7-Tage-Inzidenz* der Neuinfektionen",
       x = "Zeitverlauf",
       y = "Fälle pro 100,000 Einwohner in den letzten 7 Tagen",
       color = "",
       caption = "*basiert auf wann der Fall beim Gesundheitsamt gemeldet ist, nicht wann der RKI ihn erfasst") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.justification = "left",
        legend.margin = margin(-18, 0, 0, 0),
        axis.title.x = element_text(size = 10)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  scale_x_date(date_labels = "%b\n%Y") +
  scale_color_manual(values = c("red", "black"),
                     limits = c("korrigierte Inzidenz durch Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022",
                                "Inzidenz am Veröffentlichungstag"))
dev.off()




png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_17_Inzidenzdifferenz.png"),
    width = 9000,
    height = 5000,
    res = 900)

ggplot(data = df_plot,
       aes(x = date)) +
  geom_line(aes(y = (incidence - incidence_original) / incidence_original,
                alpha = "nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022")) +
  geom_line(aes(y = (incidence_orig_plus1 - incidence_original) / incidence_original,
                alpha = "nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 1 Tag nach dem Veröffentlichungsdatum der ursprünglichen Inzidenz")) +
  labs(title = "Um wie viel Prozent erhöht sich die ursprüngliche 7-Tage-Inzidenz wegen Nachmeldungen",
       x = "Zeitverlauf",
       y = "Anstieg zur ursprünglichen Inzidenz",
       alpha = "",
       caption = "*basiert auf wann der Fall beim Gesundheitsamt gemeldet ist, nicht wann der RKI ihn erfasst") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.justification = "left",
        legend.margin = margin(-25, 0, 0, 0),
        axis.title.x = element_text(size = 10)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  scale_x_date(date_labels = "%b\n%Y") +
  scale_y_continuous(labels = scales::percent) +
  scale_alpha_manual(values = c(1, 0.3),
                     limits = c("nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022",
                                "nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 1 Tag nach dem Veröffentlichungsdatum der ursprünglichen Inzidenz"))
dev.off()

```





###############################################

# Altersgruppen

###############################################

```{r Calc Abs Meldeverzug Altersgruppen}

# creating a vector which contains subsets of the complete cases grouped by state 
age_group_names <- sort(unique(cases_complete$age_group)) #to make sure unbekannt is at the end
case_age_group <- vector(mode = "list", length = 6)

for (i in 1:6) {
  case_age_group[[i]] <- subset(cases_complete, age_group == age_group_names[[i]])
}

```



```{r Slide 19 Proportion delayed cases per age group}

case_age_group_delay <- data.frame(date = double(),
                               late_cases = double(),
                               cases = double(),
                               prop_late = double(),
                               late_roll = double(),
                               age_group = character())


# Calculates the number of late cases
temp <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  temp[[i]] <- subset(case_age_group[[i]], new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}

# Calculates the number of total cases
temp2 <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  temp2[[i]] <- subset(case_age_group[[i]], new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}


for (i in 1:6) {
  names(temp[[i]]) <- c("date", "late_cases")
  names(temp2[[i]]) <- c("date", "cases")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  temp[[i]] <- left_join(dates, data.frame(temp[[i]]), by = "date")
  temp[[i]] <- left_join(data.frame(temp[[i]]), data.frame(temp2[[i]]), by = "date")
  temp[[i]]$prop_late <- temp[[i]]$late_cases / temp[[i]]$cases
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  temp[[i]]$late_roll <- rollmean(temp[[i]]$prop_late, 7, fill = "extend",  align = "right")
  
  temp[[i]]$age_group <- age_group_names[[i]]
  case_age_group_delay <- rbind(case_age_group_delay, temp[[i]])
}
rm(temp, temp2)

###### NEED TO CHANGE VARIABLES FOR THIS GRAPH

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_age_group_delay,
       aes(x = date)) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  facet_wrap(~age_group) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug (pro Altersgruppe)",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_19_Meldeverzug_Altersgruppe.png", height = 5, width = 9)

```



```{r Slide 20 Absolute delay q90 per age group}

# Relies on case_age_group from {r Calc Abs Meldeverzug Altersgruppen}


# Right now I'm manually repeating the calculation for quantile 50, 90, 95 and 99.
# In the final version I might implement this using a paste function for the names
# which draws the quantile values from an input vector and creates the according
# number of graphs as well. For now, the way it is now works.


# q90

age_group_q90_temp <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  age_group_q90_temp[[i]] <- subset(case_age_group[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
}

age_group_q90 <- data.frame(date = double(), 
                        q90_delay = double(), 
                        age_group = character())
for (i in 1:6) {
  names(age_group_q90_temp[[i]]) <- c("date", "q90_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  age_group_q90_temp[[i]] <- left_join(dates, data.frame(age_group_q90_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  age_group_q90_temp[[i]]$q90_roll <- rollmean(age_group_q90_temp[[i]]$q90_delay, 7, fill = "extend",  align = "right")
  
  age_group_q90_temp[[i]]$age_group <- age_group_names[[i]]
  age_group_q90 <- rbind(age_group_q90, age_group_q90_temp[[i]])
}
rm(age_group_q90_temp)


## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = age_group_q90,
       aes(x = date)) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  ylim(0, 100) +
  facet_wrap(~age_group, nrow = 2) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden (pro Altersgruppe)",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_20_Meldeverzug_q90_Altersgruppe.png", height = 5, width = 9)

```


###############################################

# Bundesländer

###############################################


```{r Calc Abs Meldeverzug Bundesland}

# creating a vector which contains subsets of the complete cases grouped by state 
state_names <- unique(cases_complete$state)
case_state <- vector(mode = "list", length = 16)

for (i in 1:16) {
  case_state[[i]] <- subset(cases_complete, state == state_names[[i]])
}

```



```{r Slide 22 Proportion delay per state}

case_state_delay <- data.frame(date = double(),
                               late_cases = double(),
                               cases = double(),
                               prop_late = double(),
                               late_roll = double(),
                               state = character())


# Calculates the number of late cases
temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  temp[[i]] <- subset(case_state[[i]], new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}

# Calculates the number of total cases
temp2 <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  temp2[[i]] <- subset(case_state[[i]], new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}


for (i in 1:16) {
  names(temp[[i]]) <- c("date", "late_cases")
  names(temp2[[i]]) <- c("date", "cases")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  temp[[i]] <- left_join(dates, data.frame(temp[[i]]), by = "date")
  temp[[i]] <- left_join(data.frame(temp[[i]]), data.frame(temp2[[i]]), by = "date")
  temp[[i]]$prop_late <- temp[[i]]$late_cases / temp[[i]]$cases
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  temp[[i]]$late_roll <- rollmean(temp[[i]]$prop_late, 7, fill = "extend",  align = "right")
  
  temp[[i]]$state <- state_names[[i]]
  case_state_delay <- rbind(case_state_delay, temp[[i]])
}
rm(temp, temp2)

###### NEED TO CHANGE VARIABLES FOR THIS GRAPH

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_state_delay,
       aes(x = date)) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  facet_wrap(~state) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug (pro Bundesland)",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_22_Meldeverzug_Bundesland.png", height = 5, width = 9)

```



```{r Slide 23 Absolute delay q90 per state}

# Relies on case_state from {r Calc Abs Meldeverzug Bundesland}


# Right now I'm manually repeating the calculation for quantile 50, 90, 95 and 99.
# In the final version I might implement this using a paste function for the names
# which draws the quantile values from an input vector and creates the according
# number of graphs as well. For now, the way it is now works.


# q50

state_q50_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q50_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .50, weight = cases))
}

state_q50 <- data.frame(date = double(), 
                        q50_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q50_temp[[i]]) <- c("date", "q50_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  state_q50_temp[[i]] <- left_join(dates, data.frame(state_q50_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  state_q50_temp[[i]]$q50_roll <- rollmean(state_q50_temp[[i]]$q50_delay, 7, fill = "extend",  align = "right")
  
  state_q50_temp[[i]]$state <- state_names[[i]]
  state_q50 <- rbind(state_q50, state_q50_temp[[i]])
}
rm(state_q50_temp)



# q90

state_q90_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q90_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
}

state_q90 <- data.frame(date = double(), 
                        q90_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q90_temp[[i]]) <- c("date", "q90_delay")
  state_q90_temp[[i]] <- left_join(dates, data.frame(state_q90_temp[[i]]), by = "date")
  
  state_q90_temp[[i]]$q90_roll <- rollmean(state_q90_temp[[i]]$q90_delay, 7, fill = "extend",  align = "right")
  
  state_q90_temp[[i]]$state <- state_names[[i]]
  state_q90 <- rbind(state_q90, state_q90_temp[[i]])
}
rm(state_q90_temp)



# q95
state_q95_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q95_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .95, weight = cases))
}

state_q95 <- data.frame(date = double(), 
                        q95_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q95_temp[[i]]) <- c("date", "q95_delay")
  state_q95_temp[[i]] <- left_join(dates, data.frame(state_q95_temp[[i]]), by = "date")
  
  state_q95_temp[[i]]$q95_roll <- rollmean(state_q95_temp[[i]]$q95_delay, 7, fill = "extend",  align = "right")
  
  state_q95_temp[[i]]$state <- state_names[[i]]
  state_q95 <- rbind(state_q95, state_q95_temp[[i]])
}
rm(state_q95_temp)



# q99
state_q99_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q99_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .99, weight = cases))
}

state_q99 <- data.frame(date = double(), 
                        q99_delay = double(), 
                        state = character())

for (i in 1:16) {
  names(state_q99_temp[[i]]) <- c("date", "q99_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  state_q99_temp[[i]] <- left_join(dates, data.frame(state_q99_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost value
  # will be repeated. Using NA (or NULL) as a method creates an NA value for the
  # entire 7 days which creates gaps in the visualisation
  state_q99_temp[[i]]$q99_roll <- rollmean(state_q99_temp[[i]]$q99_delay, 7, fill = "extend",  align = "right")
  
  state_q99_temp[[i]]$state <- state_names[[i]]
  state_q99 <- rbind(state_q99, state_q99_temp[[i]])
}

rm(state_q99_temp, publication_dates)

# Data Merge

state_q_delay <- cbind(state_q50,
                       state_q90$q90_delay, 
                       state_q90$q90_roll, 
                       state_q95$q95_delay, 
                       state_q95$q95_roll, 
                       state_q99$q99_delay,
                       state_q99$q99_roll)

names(state_q_delay) <- c("date", 
                          "q50_delay",
                          "q50_roll",
                          "state",
                          "q90_delay",
                          "q90_roll",
                          "q95_delay",
                          "q95_roll",
                          "q99_delay",
                          "q99_roll")

rm(state_q50, state_q90, state_q95, state_q99)

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

# Transformation so that the individual day delays >100 are still shown on the plot
state_q_delay2 <- state_q_delay
state_q_delay2$q90_delay[state_q_delay2$q90_delay > 100] <- 100

ggplot(data = state_q_delay2,
       aes(x = date)) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  ylim(0, 100) +
  facet_wrap(~state, nrow = 4) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden (pro Bundesland)",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_Vortrag_Folie_23_Meldeverzug_q90_Bundesland_rescale.png", height = 5, width = 9)

rm(state_q_delay2)


```



### Plots for deaths

Create the plots for presentation.

```{r create presentation plots for deaths }
cases_exa_deaths_all <- subset(cases_exa, new_fatality == 1) %>%
  group_by(date) %>%
  summarise(
    avg_rep_death = as.numeric(weighted.mean(ADD_delay, deaths))
  )
cases_exa_deaths_all <- subset(cases_exa_deaths_all, date >= as.Date("2020-03-27") & date < as.Date("2022-01-01"))
cases_exa_deaths_all <- cases_exa_deaths_all %>%
  mutate(
    sma_avg_rep_death = coalesce(rollmean(avg_rep_death, 7, align="right", fill = NA), avg_rep_death)
  )
png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_25_Todesfalle.png"), width=6000, height = 3000, res=900)
ggplot(cases_exa_deaths_all, aes(x=date)) + 
  geom_line(aes(y = avg_rep_death, colour = "Zeit pro Fall")) + 
  geom_point(aes(y = avg_rep_death), color="black", shape=20, size=.2) + 
  geom_line(aes(y = sma_avg_rep_death, colour = "Gleitender Mittelwert (7-Tage rückblickend)")) + 
  labs(title="Durchschnittliche Zeit zwischen Meldedatum und Todesmeldung",
       x="Meldedatum (Infektion)",
       y="Tage",
       caption="Zeitraum 27.03.2020 bis 31.12.2021") + 
  scale_x_date(date_labels="%b\n%Y") + 
  scale_colour_manual(name = "", values = c(`Zeit pro Fall` = "grey", `Gleitender Mittelwert (7-Tage rückblickend)` = "red")) +
  geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")), color="green",size=0.5, linetype=2) + 
  theme_bw() +
  theme(legend.position = "bottom",
        legend.justification = "left")
dev.off()
cases_exa_deaths <- subset(cases_exa, new_fatality == 1) %>%
  group_by(age_group, date) %>%
  summarise(
    daily_deaths_by_age_group = sum(deaths),
    avg_rep_death = as.numeric(weighted.mean(ADD_delay, deaths))
  )
cases_exa_deaths <- subset(cases_exa_deaths, age_group != "unbekannt" & date >= as.Date("2020-03-27") & date < as.Date("2022-01-01"))
cases_exa_deaths <- cases_exa_deaths %>%
  mutate(
    sma_avg_rep_death = coalesce(rollmean(avg_rep_death, 7, align="right", fill = NA), avg_rep_death)
  )
deaths_by_age_group <- cases_exa_deaths %>%
  group_by(age_group) %>%
  summarise(
    total_deaths = sum(daily_deaths_by_age_group, na.rm = TRUE)
  ) %>%
  mutate(
    pct_deaths = total_deaths/sum(total_deaths)*100
  )
# Extend with percentage of total
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A00-A04")] <- "A00-A04 (0,11 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A05-A14")] <- "A05-A14 (0,06 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A15-A34")] <- "A15-A34 (0,40 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A35-A59")] <- "A35-A59 (5,39 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A60-A79")] <- "A60-A79 (30,60 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A80+")] <- "A80+ (63,50 %)"
  
unique(cases_exa_deaths$age_group)
png(file.path(".", "05_Grafiken", "Grafik_Vortrag_Folie_28_Todesfalle_Altersgruppen.png"), width = 6000, height = 3000, res = 900)
ggplot(cases_exa_deaths, aes(x = date)) + 
  geom_line(aes(y = avg_rep_death), color = "grey") + 
  geom_point(aes(y = avg_rep_death), color = "black", shape = 20, size = .2) + 
  geom_line(aes(y = sma_avg_rep_death), color = "red") + 
  facet_wrap(~age_group) + 
  labs(title = "Durchschnittliche Zeit zwischen Meldedatum und Todesmeldung",
       x = "Meldedatum (Infektion)",
       y = "Tage",
       caption = '7 Tage SMA, ohne "unbekannt", n(Todesmeldungen) = 117471, Zeitraum 27.03.2020 bis 31.12.2021') + 
  scale_x_date(date_labels = "%b\n%Y") + 
  geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")), color = "green", size = 0.5, linetype = 2) + 
  theme_bw()
dev.off()
```

#########################
#########################

# Creation of visualisations after the presentation using the extended dataset and incorporating the feedback

Recreate the plots for the presentation with the extended data and suggested adaptions (such as yearly separator lines in the back, y-axis starts with 0 etc.)

#########################
#########################

We read in the extended data set. 

```{r NEW data import}

######################################
#### Data import
######################################

# Requires: 03_8_cases_complete_extended_ADD.rds
#           03_9_RKI_covid_2022-03-26.Rds
#
# Output:   cases_complete (df)
#           cases_exa (df)
#           current_covid (df)

setwd(getwd()) # Change working directory if necessary

cases_complete <- readRDS("03_8_cases_complete_extended_ADD.rds")

# Remove the first days 0 entries
cases_exa <- subset(cases_complete, new_case != 0 | publication_date != as.Date("2020-03-27"))


# RKI Covid data downloaded on the 26th of March 2022 to visualise pandemic
current_covid <- readRDS("03_9_RKI_covid_2022-03-26.Rds")

######################################

```



```{r NEW delay category calculations}

######################################
#### Universal variables
######################################

# Calculates whether a case report was delayed, or not
cases_complete$ADD_delay_break <- cut(as.numeric(cases_complete$ADD_delay), 
                         breaks = c(-1, 0, Inf),
                         labels = c("on time", "late"))

######################################

```



```{r NEW Slide 2 All covid cases}

######################################
#### Daily covid cases since the start of the pandemic
######################################

# Current RKI data is in German, thus variable names are different
current_covid <- current_covid[c( "Meldedatum", "AnzahlFall")]
names(current_covid) <- c("date", "cases")

# transformation so case numbers are displayed properly
current_covid$date <- as.Date(current_covid$date)
current_covid$cases <- current_covid$cases / 1000

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = current_covid, 
       aes(x = date, y = cases)) +
  geom_bar(stat = "identity") +
  geom_vline(xintercept = as.Date(c("2020-01-01", "2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  labs(title = "Der Verlauf der Pandemie: Neue Coronafälle pro Tag",
       x = "Datum des Falles",
       y = "Anzahl an Fälle (in Tsd.)") +
  theme_bw()

ggsave("Grafik_UeberArb_Folie_02_Covidfälle.png", height = 5, width = 9)

######################################

```



```{r NEW Slide 10 Histogram of cases with delays}

######################################
#### Histogram of all cases with specified delays
######################################

# Simple plot of how many cases are in each delay category
delay_overall <- subset(cases_complete, new_case == 1) %>%
    group_by(ADD_delay) %>%
    summarise(sum(cases))
names(delay_overall) <- c("delay", "cases")

# Need to create categories because without the graph is unusable (delays extend
# up to 736 days into the future with 632 different delay observations as a whole)
delay_overall$delay_cat <- cut(as.numeric(delay_overall$delay),
                               breaks = c(-1, 0, 1, 2, 3, 4, 5, 10, 30, Inf),
                               labels = c("0", "1", "2", "3", "4", "5", "5-10", "10-30", "30+"))

delay_overall$cases <- delay_overall$cases / sum(subset(cases_complete, new_case == 1)$cases) 

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = aggregate(cases ~ delay_cat, delay_overall, sum), 
       aes(x = delay_cat, y = cases, fill = factor(ifelse(delay_cat == "0","Highlighted","Normal")))) +
  geom_bar(stat = "identity") +
  scale_fill_manual(name = "delay_cat", values = c("darkolivegreen4","grey50")) +
  labs(title = "Anteil an Fällen mit Meldeverzug",
       x = "Meldeverzug in Tagen",
       y = "Anteil aller Fälle") +
  theme_bw() +
  theme(legend.position = "none")

ggsave("Grafik_UeberArb_Folie_10_Meldeverzug_Hist.png", height = 5, width = 9)

```



### Plots for weekly cycles

Create the plots for the presentation.

```{r NEW Slide 11 Weekly cycles}

######################################
#### Cyclicality of new cases and delays
######################################

cases_exa$rep_delay_cut <- cut(as.numeric(cases_exa$ADD_delay),
                               breaks = c(-1, 0, Inf),
                               labels = c("on time","late"))
date <- seq.Date(from = as.Date("2020-03-27"),
                 to = as.Date("2022-02-22"),
                 by = "day")

temp_date <- date

cases_limited <- subset(cases_exa,date %in% temp_date)
cases_limited$date_cut <- cut(cases_limited$date,breaks=as.Date(c("2020-03-25","2020-07-26","2020-11-26","2021-03-26","2021-07-26","2021-11-26","2022-02-23")),labels=c("27.03 - 26.07.2020","27.07 - 26.11.2020","27.11.2020 - 26.03.2021","27.03 - 26.07.2021","27.07 - 26.11.2021","27.11.2021 - 22.02.2022"))
temp <- subset(cases_limited,new_case==1) %>%
  group_by(date_cut,date,rep_delay_cut) %>%
  summarise(n=sum(cases)) %>%
  mutate(freq=n/sum(n))

p1 <- ggplot(subset(cases_limited,new_case==1&date %in% seq.Date(from=as.Date("2020-11-27"),to=as.Date("2021-07-26"),by="day")),aes(x=date,y=cases))+geom_vline(xintercept = seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),color="green",size=0.5,linetype=2) +  stat_summary(fun="sum",geom="line")+scale_x_date(breaks=seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),date_labels = "%a\n%b\n%Y") + labs(title="Wöchentlicher Zyklus der Anzahl der Neuinfektionsmeldungen im Zeitraum 27.11.2020 - 26.07.2021",x="Meldedatum",y="Fälle") + theme_bw()+theme(axis.title.x =element_text(size=10),axis.text.x=element_text(size=7))

p2 <- ggplot(subset(temp,rep_delay_cut=="late"&date %in% seq.Date(from=as.Date("2020-11-27"),to=as.Date("2021-07-26"),by="day")),aes(x=date)) + geom_vline(xintercept = seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),color="green",size=0.5,linetype=2) + geom_line(aes(y=freq)) + theme_bw() + scale_y_continuous(limits=c(0,1))+ scale_x_date(breaks=seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),date_labels = "%a\n%b\n%Y") + labs(title="Wöchentlicher Zyklus des Anteils der Spätmeldungen* im Zeitraum 27.11.2020 - 26.07.2021",x="Meldedatum",caption="*Meldungen mit Verzug mind. 1 Tag.\nfreq = n(Spätmeldugen am Meldedatum) / n(alle Meldungen am Meldedatum)") + theme(axis.title.x =element_text(size=10),axis.text.x=element_text(size=7))

png(file.path(".", "05_Grafiken", "Grafik_UeberArb_Folie_11_Zyklus.png"), width=9000, height = 5000, res=900)
grid.arrange(p1,p2,nrow=2)
dev.off()

png(file.path(".","05_Grafiken","Grafik_UeberArb_Folie_29_Neuinfektionen_Zyklus.png"),width=14000, height=7000,res=900)
ggplot(subset(cases_limited,new_case==1),aes(x=date,y=cases))+geom_vline(xintercept = seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),color="green",size=0.5,linetype=2) + stat_summary(fun="sum",geom="line")+scale_x_date(breaks=seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),date_labels = "%a\n%b\n%Y") + labs(title="Wöchentlicher Zyklus der Anzahl der Neuinfektionsmeldungen",x="Meldedatum",y="Fälle") + theme_bw()+theme(axis.title.x =element_text(size=10),axis.text.x=element_text(size=7)) + facet_wrap(~date_cut,scales="free")
dev.off()

png(file.path(".","05_Grafiken","Grafik_UeberArb_Folie_30_Spaetmeldungsanteil_Zyklus.png"),width=14000, height=7000,res=900)
ggplot(subset(temp,rep_delay_cut=="late"),aes(x=date)) + geom_vline(xintercept = seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),color="green",size=0.5,linetype=2)+geom_line(aes(y=freq)) + theme_bw() + scale_x_date(breaks=seq.Date(from=as.Date("2020-03-29"),to=as.Date("2022-02-22"),by="week"),date_labels = "%a\n%b\n%Y") + labs(title="Wöchentlicher Zyklus des Anteils der Spätmeldungen*",x="Meldedatum",caption="*Meldungen mit Verzug mind. 1 Tag.\nfreq = n(Spätmeldugen am Meldedatum) / n(alle Meldungen am Meldedatum)") + scale_y_continuous(limits=c(0,1)) + theme(axis.title.x =element_text(size=10),axis.text.x=element_text(size=7))+facet_wrap(~date_cut,scales="free")
dev.off()

rm(p1, p2, temp)
```


```{r NEW Slide 12 Daily proportion of delayed cases}


case_delay <- data.frame(date = double(),
                         late_cases = double(),
                         cases = double(),
                         prop_late = double(),
                         late_roll = double())


# Calculates the number of late cases
temp <- subset(cases_complete, new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
names(temp) <- c("date", "late_cases")

# Calculates the number of total cases
temp2 <- subset(cases_complete, new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
names(temp2) <- c("date", "cases")
  
# ensuring that the dataframe has a list of complete dates (introduces NAs)
temp <- left_join(data.frame(date), data.frame(temp), by = "date")
temp <- left_join(data.frame(temp), data.frame(temp2), by = "date")
temp$prop_late <- temp$late_cases / temp$cases
  
# Decided to use the "extend" method so if there is an NA, the leftmost rolling
# average value will be repeated until a new one can be calculated. This also
# means that an NA value creates a plateau of the average for 7 values. Using 
# NA (or NULL) as the method creates an NA value for the entire 7 days which 
# creates gaps in the visualisation
temp$late_roll <- rollmean(temp$prop_late, 7, fill = "extend",  align = "right")
case_delay <- rbind(case_delay, temp)

rm(temp, temp2)

## REVISED Visualisation
# Moved the vertical year denominator behind the other lines

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_delay,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  ylim(0, 1) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_12_Meldeverzug_Anteil.png", height = 5, width = 9)

######################################

```



```{r NEW Slides 13-15 Delay quantiles}

# ?????????? LOG10

# Calculation of quantile delay on all cases
delay_overall_quant <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .50, weight = cases))
names(delay_overall_quant) <- c("date", "q50_delay")
  
delay_overall_quant <- left_join(data.frame(date), delay_overall_quant, by = "date")
delay_overall_quant$q50_roll <- rollmean(delay_overall_quant$q50_delay, 7, fill = "extend",  align = "right")


q90 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
names(q90) <- c("date", "q90_delay")
q90 <- left_join(data.frame(date), q90, by = "date")
q90$q90_roll <- rollmean(q90$q90_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q90_delay <- q90$q90_delay
delay_overall_quant$q90_roll <- q90$q90_roll
rm(q90)


q95 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .95, weight = cases))
names(q95) <- c("date", "q95_delay")
q95 <- left_join(data.frame(date), q95, by = "date")
q95$q95_roll <- rollmean(q95$q95_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q95_delay <- q95$q95_delay
delay_overall_quant$q95_roll <- q95$q95_roll
rm(q95)


q99 <- subset(cases_complete, new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .99, weight = cases))
names(q99) <- c("date", "q99_delay")
q99 <- left_join(data.frame(date), q99, by = "date")
q99$q99_roll <- rollmean(q99$q99_delay, 7, fill = "extend",  align = "right")
delay_overall_quant$q99_delay <- q99$q99_delay
delay_overall_quant$q99_roll <- q99$q99_roll
rm(q99)


## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))


# Absolute delay of q90 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert")) +
  ylim(0, 400) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_13_Meldeverzug_q90.png", height = 5, width = 9)


# Absolute delay of q95 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = q95_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q95_roll, colour = "Gewichteter Mittelwert")) +
  ylim(0, 400) +
  labs(title = "Zeit nach der 95% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 95%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_14_Meldeverzug_q95.png", height = 5, width = 9)


# Absolute delay of q99 case
ggplot(data = delay_overall_quant,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = q99_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q99_roll, colour = "Gewichteter Mittelwert")) +
  ylim(0, 400) +
  labs(title = "Zeit nach der 99% der Fälle berichtet wurden",
       x = "Datum des Falles",
       y = "Meldeverzug des 99%igen Fall in Tagen",
       caption = "Meldeverzug auf individuelle Fälle gewichtet. Gleitender Mittelwert (7-Tage rückblickend) bei dem NAs ersetzt wurden.") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_15_Meldeverzug_q99.png", height = 5, width = 9)

```



### Plots 7-day incidence

Recreate the plots after presentation.

```{r NEW Slides 16-17 recreate plots for 7-day-incidence after presentation}
population_2019 <- 83166711
population_2020 <- 83155031
date <- seq.Date(from=as.Date("2020-03-27"),to=as.Date("2022-02-22"),by="day")

incidence <- vec_rep(0,698)
temp <- date
# 7-days-incidence can only be computed with i>=8
# for 2020
for (i in 8:275) {
  # take all addtional reports and corrections till 22.02.2022
  incidence[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)])$cases)/population_2019*100000 
}
# from 2021
for (i in 276:698) {
  # take all additional reports and corrections till 22.02.2022
  incidence[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)])$cases)/population_2020*100000
}

incidence_original <- vec_rep(0,698)
# for 2020
for (i in 8:275) {
  # Take only reports and corrections until the publication date of the incidence
  incidence_original[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):i])$cases)/population_2019*100000
}
# from 2021
for (i in 276:698) {
  # Take only reports and corrections until the publication date of the incidence
  incidence_original[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):i])$cases)/population_2020*100000
}

incidence_orig_plus1 <- vec_rep(0,698)
# for 2020
for (i in 8:275) {
  # Take only reports and corrections up to the date of the incidence + 1
  incidence_orig_plus1[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):(i+1)])$cases)/population_2019*100000
}
# from 2021
for (i in 276:698) {
  # Take only reports and corrections up to the date of the incidence + 1
  incidence_orig_plus1[i] <- sum(subset(cases_exa,new_case %in% c(1,-1) & date %in% temp[(i-7):(i-1)] & publication_date %in% temp[(i-6):(i+1)])$cases)/population_2020*100000
}

df_plot <- data.frame(date)
df_plot$incidence <- incidence
df_plot$incidence_original <- incidence_original
df_plot$incidence_orig_plus1 <- incidence_orig_plus1

png(file.path(".","05_Grafiken","Grafik_UeberArb_Folie_16_Inzidenz.png"),width=9000, height=5000,res=900)
ggplot(df_plot,aes(x=date)) + geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")),color="green",size=0.5,linetype=2) + geom_line(aes(y=incidence,color="korrigierte Inzidenz durch Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022"),linetype=2) + geom_line(aes(y=incidence_original, color="Inzidenz am Veröffentlichungstag")) + labs(title="Einfluss von Nachmeldungen & -korrekturen auf die 7-Tage-Inzidenz* der Neuinfektionen",x="Zeitverlauf",y="Fälle pro 100,000 Einwohner in den letzten 7 Tagen",color="",caption="*basiert auf wann der Fall beim Gesundheitsamt gemeldet ist, nicht wann der RKI ihn erfasst") + theme_bw() + theme(legend.position = "bottom",legend.direction = "vertical",legend.justification = "left",legend.margin=margin(-18, 0, 0, 0), axis.title.x = element_text(size=10)) + scale_x_date(date_labels="%b\n%Y") + scale_color_manual(values=c("red","black"),limits=c("korrigierte Inzidenz durch Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022","Inzidenz am Veröffentlichungstag"))
dev.off()

png(file.path(".","05_Grafiken","Grafik_UeberArb_Folie_17_Incidenzdifferenz.png"),width=9000, height=5000,res=900)
ggplot(df_plot,aes(x=date)) + geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")),color="green",size=0.5,linetype=2) + geom_line(aes(y=(incidence-incidence_original)/incidence_original,alpha="nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022")) +  geom_line(aes(y=(incidence_orig_plus1-incidence_original)/incidence_original,alpha="nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 1 Tag nach dem Veröffentlichungsdatum der ursprünglichen Inzidenz")) + labs(title="Um wie viel Prozent erhöht sich die ursprüngliche 7-Tage-Inzidenz wegen Nachmeldungen",x="Zeitverlauf",y="Anstieg zur ursprünglichen Inzidenz",alpha="",caption="*basiert auf wann der Fall beim Gesundheitsamt gemeldet ist, nicht wann der RKI ihn erfasst") + theme_bw() + theme(legend.position = "bottom",legend.direction = "vertical",legend.justification = "left",legend.margin=margin(-25, 0, 0, 0), axis.title.x = element_text(size=10)) + scale_x_date(date_labels="%b\n%Y") + scale_y_continuous(labels=scales::percent) + scale_alpha_manual(values=c(1,0.3),limits=c("nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 22.02.2022","nach Betrachtung aller Nachmeldungen & -korrekturen bis zum 1 Tag nach dem Veröffentlichungsdatum der ursprünglichen Inzidenz"))
dev.off()
```




###############################################

# Altersgruppen

###############################################

```{r NEW Calc Abs Meldeverzug Altersgruppen}

# creating a vector which contains subsets of the complete cases grouped by state 
age_group_names <- sort(unique(cases_complete$age_group)) #to make sure unbekannt is at the end
case_age_group <- vector(mode = "list", length = 6)

for (i in 1:6) {
  case_age_group[[i]] <- subset(cases_complete, age_group == age_group_names[[i]])
}

```



```{r NEW Slide 19 Proportion delayed cases per age group}

case_age_group_delay <- data.frame(date = double(),
                               late_cases = double(),
                               cases = double(),
                               prop_late = double(),
                               late_roll = double(),
                               age_group = character())


# Calculates the number of late cases
temp <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  temp[[i]] <- subset(case_age_group[[i]], new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}

# Calculates the number of total cases
temp2 <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  temp2[[i]] <- subset(case_age_group[[i]], new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}


for (i in 1:6) {
  names(temp[[i]]) <- c("date", "late_cases")
  names(temp2[[i]]) <- c("date", "cases")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  temp[[i]] <- left_join(data.frame(date), data.frame(temp[[i]]), by = "date")
  temp[[i]] <- left_join(data.frame(temp[[i]]), data.frame(temp2[[i]]), by = "date")
  temp[[i]]$prop_late <- temp[[i]]$late_cases / temp[[i]]$cases
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  temp[[i]]$late_roll <- rollmean(temp[[i]]$prop_late, 7, fill = "extend",  align = "right")
  
  temp[[i]]$age_group <- age_group_names[[i]]
  case_age_group_delay <- rbind(case_age_group_delay, temp[[i]])
}
rm(temp, temp2)

###### NEED TO CHANGE VARIABLES FOR THIS GRAPH

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_age_group_delay,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  facet_wrap(~age_group) +
  ylim(0, 1) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug (pro Altersgruppe)",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_19_Meldeverzug_Altersgruppe.png", height = 5, width = 9)

```



```{r NEW Slide 20 Absolute delay q90 per age group}

# Relies on case_age_group from {r Calc Abs Meldeverzug Altersgruppen}


# Right now I'm manually repeating the calculation for quantile 50, 90, 95 and 99.
# In the final version I might implement this using a paste function for the names
# which draws the quantile values from an input vector and creates the according
# number of graphs as well. For now, the way it is now works.


# q90

age_group_q90_temp <- vector(mode = "list", length = 6)
for (i in 1:6) { 
  age_group_q90_temp[[i]] <- subset(case_age_group[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
}

age_group_q90 <- data.frame(date = double(), 
                        q90_delay = double(), 
                        age_group = character())
for (i in 1:6) {
  names(age_group_q90_temp[[i]]) <- c("date", "q90_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  age_group_q90_temp[[i]] <- left_join(data.frame(date), data.frame(age_group_q90_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  age_group_q90_temp[[i]]$q90_roll <- rollmean(age_group_q90_temp[[i]]$q90_delay, 7, fill = "extend",  align = "right")
  
  age_group_q90_temp[[i]]$age_group <- age_group_names[[i]]
  age_group_q90 <- rbind(age_group_q90, age_group_q90_temp[[i]])
}
rm(age_group_q90_temp)


## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = age_group_q90,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  ylim(0, 100) +
  facet_wrap(~age_group, nrow = 2) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden (pro Altersgruppe)",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_20_Meldeverzug_q90_Altersgruppe.png", height = 5, width = 9)

```


###############################################

# Bundesländer

###############################################


```{r NEW Calc Abs Meldeverzug Bundesland}

# creating a vector which contains subsets of the complete cases grouped by state 
state_names <- unique(cases_complete$state)
case_state <- vector(mode = "list", length = 16)

for (i in 1:16) {
  case_state[[i]] <- subset(cases_complete, state == state_names[[i]])
}

```



```{r NEW Slide 22 Proportion delay per state}

case_state_delay <- data.frame(date = double(),
                               late_cases = double(),
                               cases = double(),
                               prop_late = double(),
                               late_roll = double(),
                               state = character())


# Calculates the number of late cases
temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  temp[[i]] <- subset(case_state[[i]], new_case == 1 & date >= as.Date("2020-03-27") & ADD_delay_break == "late") %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}

# Calculates the number of total cases
temp2 <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  temp2[[i]] <- subset(case_state[[i]], new_case == 1 & date >= as.Date("2020-03-27")) %>%
    group_by(date) %>%
    summarise(sum(cases, na.rm = TRUE))
}


for (i in 1:16) {
  names(temp[[i]]) <- c("date", "late_cases")
  names(temp2[[i]]) <- c("date", "cases")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  temp[[i]] <- left_join(data.frame(date), data.frame(temp[[i]]), by = "date")
  temp[[i]] <- left_join(data.frame(temp[[i]]), data.frame(temp2[[i]]), by = "date")
  temp[[i]]$prop_late <- temp[[i]]$late_cases / temp[[i]]$cases
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  temp[[i]]$late_roll <- rollmean(temp[[i]]$prop_late, 7, fill = "extend",  align = "right")
  
  temp[[i]]$state <- state_names[[i]]
  case_state_delay <- rbind(case_state_delay, temp[[i]])
}
rm(temp, temp2)

## Visualisations

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

ggplot(data = case_state_delay,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = prop_late, colour = "Meldeverzug (Anteil)")) +
  geom_line(aes(y = late_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  ylim(0, 1) +
  facet_wrap(~state) +
  labs(title = "Täglicher Anteil an Fällen mit Meldeverzug (pro Bundesland)",
       x = "Datum des Falles",
       y = "Anteil an zum Datum gemeldeten Fällen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Anteil)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_22_Meldeverzug_Bundesland.png", height = 5, width = 9)

```



```{r NEW Slide 23 Absolute delay q90 per state}

# Relies on case_state from {r Calc Abs Meldeverzug Bundesland}


# Right now I'm manually repeating the calculation for quantile 50, 90, 95 and 99.
# In the final version I might implement this using a paste function for the names
# which draws the quantile values from an input vector and creates the according
# number of graphs as well. For now, the way it is now works.


# q50

state_q50_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q50_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .50, weight = cases))
}

state_q50 <- data.frame(date = double(), 
                        q50_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q50_temp[[i]]) <- c("date", "q50_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  state_q50_temp[[i]] <- left_join(data.frame(date), data.frame(state_q50_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost rolling
  # average value will be repeated until a new one can be calculated. This also
  # means that an NA value creates a plateau of the average for 7 values. Using 
  # NA (or NULL) as the method creates an NA value for the entire 7 days which 
  # creates gaps in the visualisation
  state_q50_temp[[i]]$q50_roll <- rollmean(state_q50_temp[[i]]$q50_delay, 7, fill = "extend",  align = "right")
  
  state_q50_temp[[i]]$state <- state_names[[i]]
  state_q50 <- rbind(state_q50, state_q50_temp[[i]])
}
rm(state_q50_temp)



# q90

state_q90_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q90_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .90, weight = cases))
}

state_q90 <- data.frame(date = double(), 
                        q90_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q90_temp[[i]]) <- c("date", "q90_delay")
  state_q90_temp[[i]] <- left_join(data.frame(date), data.frame(state_q90_temp[[i]]), by = "date")
  
  state_q90_temp[[i]]$q90_roll <- rollmean(state_q90_temp[[i]]$q90_delay, 7, fill = "extend",  align = "right")
  
  state_q90_temp[[i]]$state <- state_names[[i]]
  state_q90 <- rbind(state_q90, state_q90_temp[[i]])
}
rm(state_q90_temp)



# q95
state_q95_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q95_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .95, weight = cases))
}

state_q95 <- data.frame(date = double(), 
                        q95_delay = double(), 
                        state = character())
for (i in 1:16) {
  names(state_q95_temp[[i]]) <- c("date", "q95_delay")
  state_q95_temp[[i]] <- left_join(data.frame(date), data.frame(state_q95_temp[[i]]), by = "date")
  
  state_q95_temp[[i]]$q95_roll <- rollmean(state_q95_temp[[i]]$q95_delay, 7, fill = "extend",  align = "right")
  
  state_q95_temp[[i]]$state <- state_names[[i]]
  state_q95 <- rbind(state_q95, state_q95_temp[[i]])
}
rm(state_q95_temp)



# q99
state_q99_temp <- vector(mode = "list", length = 16)
for (i in 1:16) { 
  state_q99_temp[[i]] <- subset(case_state[[i]], new_case == 1) %>%
    group_by(date) %>%
    summarise(reldist::wtd.quantile(ADD_delay, q = .99, weight = cases))
}

state_q99 <- data.frame(date = double(), 
                        q99_delay = double(), 
                        state = character())

for (i in 1:16) {
  names(state_q99_temp[[i]]) <- c("date", "q99_delay")
  
  # ensuring that the dataframe has a list of complete dates (introduces NAs)
  state_q99_temp[[i]] <- left_join(data.frame(date), data.frame(state_q99_temp[[i]]), by = "date")
  
  # Decided to use the "extend" method so if there is an NA, the leftmost value
  # will be repeated. Using NA (or NULL) as a method creates an NA value for the
  # entire 7 days which creates gaps in the visualisation
  state_q99_temp[[i]]$q99_roll <- rollmean(state_q99_temp[[i]]$q99_delay, 7, fill = "extend",  align = "right")
  
  state_q99_temp[[i]]$state <- state_names[[i]]
  state_q99 <- rbind(state_q99, state_q99_temp[[i]])
}

rm(state_q99_temp, publication_dates)

# Data Merge

state_q_delay <- cbind(state_q50,
                       state_q90$q90_delay, 
                       state_q90$q90_roll, 
                       state_q95$q95_delay, 
                       state_q95$q95_roll, 
                       state_q99$q99_delay,
                       state_q99$q99_roll)

names(state_q_delay) <- c("date", 
                          "q50_delay",
                          "q50_roll",
                          "state",
                          "q90_delay",
                          "q90_roll",
                          "q95_delay",
                          "q95_roll",
                          "q99_delay",
                          "q99_roll")

rm(state_q50, state_q90, state_q95, state_q99)

## Visualisation

setwd(paste(getwd(), "/05_Grafiken", sep = ""))

# Transformation so that the individual day delays >100 are still shown on the plot
state_q_delay2 <- state_q_delay
state_q_delay2$q90_delay[state_q_delay2$q90_delay > 100] <- 100

ggplot(data = state_q_delay2,
       aes(x = date)) +
  geom_vline(xintercept = as.Date(c("2021-01-01", "2022-01-01")),
             color = "green",
             size = 0.5,
             linetype = 2) +
  geom_line(aes(y = q90_delay, colour = "Meldeverzug (Tage)")) +
  geom_line(aes(y = q90_roll, colour = "Gewichteter Mittelwert (7-Tage rückblickend)")) +
  ylim(0, 100) +
  facet_wrap(~state, nrow = 4) +
  labs(title = "Zeit nach der 90% der Fälle berichtet wurden (pro Bundesland)",
       x = "Datum des Falles",
       y = "Meldeverzug des 90%igen Fall in Tagen") +
  theme_bw() +
  scale_colour_manual(name = "",
                      values = c(`Meldeverzug (Tage)` = "gray", `Gewichteter Mittelwert (7-Tage rückblickend)` = "red")) +
  theme(legend.position = "bottom",
        legend.justification = "left")

ggsave("Grafik_UeberArb_Folie_23_Meldeverzug_q90_Bundesland_rescale.png", height = 5, width = 9)

rm(state_q_delay2)


```




### Plots for deaths

Recreate plots for death after the presentation

```{r NEW recreate the plots for death after the presentation }
cases_exa_deaths_all <- subset(cases_exa, new_fatality == 1) %>%
  group_by(date) %>%
  summarise(
    avg_rep_death = as.numeric(weighted.mean(ADD_delay, deaths))
  )
cases_exa_deaths_all <- subset(cases_exa_deaths_all, date >= as.Date("2020-03-27") & date < as.Date("2022-01-01"))
cases_exa_deaths_all <- cases_exa_deaths_all %>%
  mutate(
    sma_avg_rep_death = coalesce(rollmean(avg_rep_death, 7, align="right", fill = NA), avg_rep_death)
  )
png(file.path(".", "05_Grafiken", "Grafik_UeberArb_Folie_25_Todesfalle.png"), width=6000, height = 3000, res=900)
ggplot(cases_exa_deaths_all, aes(x=date)) + 
  geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")), color="green",size=0.5, linetype=2) + 
  geom_line(aes(y = avg_rep_death, colour = "Zeit pro Fall")) + 
  geom_point(aes(y = avg_rep_death), color="black", shape=20, size=.2) + 
  geom_line(aes(y = sma_avg_rep_death, colour = "Gleitender Mittelwert (7-Tage rückblickend)")) + 
  labs(title="Durchschnittliche Zeit zwischen Meldedatum und Todesmeldung",
       x="Meldedatum (Infektion)",
       y="Tage",
       caption="Zeitraum 27.03.2020 bis 31.12.2021") + 
  scale_x_date(date_labels="%b\n%Y") + 
  scale_colour_manual(name = "", values = c(`Zeit pro Fall` = "grey", `Gleitender Mittelwert (7-Tage rückblickend)` = "red")) +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.justification = "left")
dev.off()
cases_exa_deaths <- subset(cases_exa, new_fatality == 1) %>%
  group_by(age_group, date) %>%
  summarise(
    daily_deaths_by_age_group = sum(deaths),
    avg_rep_death = as.numeric(weighted.mean(ADD_delay, deaths))
  )
cases_exa_deaths <- subset(cases_exa_deaths, age_group != "unbekannt" & date >= as.Date("2020-03-27") & date < as.Date("2022-01-01"))
cases_exa_deaths <- cases_exa_deaths %>%
  mutate(
    sma_avg_rep_death = coalesce(rollmean(avg_rep_death, 7, align="right", fill = NA), avg_rep_death)
  )
deaths_by_age_group <- cases_exa_deaths %>%
  group_by(age_group) %>%
  summarise(
    total_deaths = sum(daily_deaths_by_age_group, na.rm = TRUE)
  ) %>%
  mutate(
    pct_deaths = total_deaths/sum(total_deaths)*100
  )
# Extend with percentage of total
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A00-A04")] <- "A00-A04 (0,11 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A05-A14")] <- "A05-A14 (0,06 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A15-A34")] <- "A15-A34 (0,40 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A35-A59")] <- "A35-A59 (5,39 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A60-A79")] <- "A60-A79 (30,60 %)"
cases_exa_deaths$age_group[which(cases_exa_deaths$age_group == "A80+")] <- "A80+ (63,50 %)"
  
unique(cases_exa_deaths$age_group)
png(file.path(".", "05_Grafiken", "Grafik_UeberArb_Folie_28_Appendix_Todesfalle_Altersgruppen.png"), width=6000, height = 3000, res=900)
ggplot(cases_exa_deaths, aes(x=date)) + 
  geom_vline(xintercept = as.Date(c("2021-01-01","2022-01-01")), color="green",size=0.5, linetype=2) + 
  geom_line(aes(y = avg_rep_death), color = "grey") + 
  geom_point(aes(y=avg_rep_death), color = "black", shape=20, size=.2) + 
  geom_line(aes(y=sma_avg_rep_death), color = "red") + 
  facet_wrap(~age_group) + 
  labs(title="Durchschnittliche Zeit zwischen Meldedatum und Todesmeldung",
       x="Meldedatum (Infektion)",
       y="Tage",
       caption='7 Tage SMA, ohne "unbekannt", n(Todesmeldungen) = 117471, Zeitraum 27.03.2020 bis 31.12.2021') + 
  scale_x_date(date_labels="%b\n%Y") + 
  theme_bw()
dev.off()
```




